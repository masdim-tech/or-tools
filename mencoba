from ortools.constraint_solver import pywrapcp
from ortools.constraint_solver import routing_enums_pb2

def create_data_model():
    """Create the data for the problem."""
    data = {}
    data['time_windows'] = [
        (0, 5),    # Depot
        (1, 4),    # Customer 1
        (2, 5),    # Customer 2
        (3, 6),    # Customer 3
        (4, 6)     # Customer 4
    ]
    data['demands'] = [0, 1, 1, 2, 1]  # Demand for each customer, 0 for depot
    data['vehicle_capacities'] = [3, 3]  # Vehicle capacities
    data['num_vehicles'] = 2  # Number of vehicles
    data['depot'] = 0  # Depot index
    
    # Coordinates of each location (x, y)
    data['locations'] = [
        (0, 0),    # Depot
        (1, 3),    # Customer 1
        (4, 3),    # Customer 2
        (6, 1),    # Customer 3
        (3, 5)     # Customer 4
    ]
    
    return data

def compute_euclidean_distance_matrix(locations):
    """Compute the Euclidean distance matrix between all locations."""
    def euclidean_distance(x1, y1, x2, y2):
        return int(((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5)
    
    size = len(locations)
    distance_matrix = {}
    for from_node in range(size):
        distance_matrix[from_node] = {}
        for to_node in range(size):
            if from_node != to_node:
                distance_matrix[from_node][to_node] = euclidean_distance(
                    locations[from_node][0], locations[from_node][1],
                    locations[to_node][0], locations[to_node][1]
                )
            else:
                distance_matrix[from_node][to_node] = 0
    return distance_matrix

def main():
    # Instantiate the data problem.
    data = create_data_model()

    # Create the distance matrix.
    distance_matrix = compute_euclidean_distance_matrix(data['locations'])

    # Create the routing index manager.
    manager = pywrapcp.RoutingIndexManager(len(distance_matrix), data['num_vehicles'], data['depot'])

    # Create Routing Model.
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_index, to_index):
        """Returns the distance between the two nodes."""
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return distance_matrix[from_node][to_node]

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)

    # Define cost of each arc.
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    # Add time windows constraint.
    def time_callback(from_index):
        """Returns the time of the node."""
        from_node = manager.IndexToNode(from_index)
        return data['time_windows'][from_node][0]  # Start of time window

    time_callback_index = routing.RegisterTransitCallback(time_callback)
    
    routing.AddDimension(
        time_callback_index,
        30,  # maximum slack time
        30,  # maximum time per vehicle (for time window constraint)
        True,  # allow waiting
        'Time'
    )

    # Add demand constraints.
    def demand_callback(from_index):
        """Returns the demand of the node."""
        from_node = manager.IndexToNode(from_index)
        return data['demands'][from_node]

    demand_callback_index = routing.RegisterTransitCallback(demand_callback)
    
    routing.AddDimensionWithVehicleCapacity(
        demand_callback_index,
        0,  # null capacity slack
        data['vehicle_capacities'],  # vehicle capacities
        True,  # Start cumul to zero
        'Capacity'
    )

    # Define search parameters.
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    
    # Solve the problem.
    solution = routing.SolveWithParameters(search_parameters)

    # Print solution on console.
    if solution:
        print_solution(manager, routing, solution, data['locations'])
    else:
        print('No solution found !')

def print_solution(manager, routing, solution, locations):
    """Print solution on console."""
    total_distance = 0
    for vehicle_id in range(routing.vehicles()):
        index = routing.Start(vehicle_id)
        route_distance = 0
        route_time = 0
        route = []
        while not routing.IsEnd(index):
            route.append(manager.IndexToNode(index))
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(previous_index, index, vehicle_id)
            route_time += solution.Value(routing.CumulVar(index, 'Time'))
        route.append(manager.IndexToNode(index))
        print(f'Route for vehicle {vehicle_id + 1}: {route}')
        print(f'Distance of the route: {route_distance} units')
        print(f'Total time for the route: {route_time} time units')
        total_distance += route_distance
    print(f'Total distance of all routes: {total_distance}')

if __name__ == '__main__':
    main()
